package org.infy.scanner.vulnerability;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Duration;
import java.util.function.Supplier;

public class RetryHandler {
    private static final Logger logger = LoggerFactory.getLogger(RetryHandler.class);
    
    private final int maxRetries;
    private final Duration initialDelay;
    private final Duration maxDelay;
    private final double backoffMultiplier;

    public RetryHandler(int maxRetries, Duration initialDelay, Duration maxDelay, double backoffMultiplier) {
        this.maxRetries = maxRetries;
        this.initialDelay = initialDelay;
        this.maxDelay = maxDelay;
        this.backoffMultiplier = backoffMultiplier;
    }

    public <T> T execute(Supplier<T> operation, String operationName) {
        int retries = 0;
        Exception lastException = null;

        while (retries < maxRetries) {
            try {
                return operation.get();
            } catch (NvdApiException e) {
                lastException = e;
                if (!e.isRetryable()) {
                    throw e;
                }
                retries++;
                if (retries < maxRetries) {
                    handleRetry(e, retries, operationName);
                }
            } catch (Exception e) {
                lastException = e;
                retries++;
                if (retries < maxRetries) {
                    handleRetry(e, retries, operationName);
                }
            }
        }

        throw new NvdApiException(
            String.format("Failed to execute %s after %d retries", operationName, maxRetries),
            lastException
        );
    }

    private void handleRetry(Exception e, int retryCount, String operationName) {
        Duration delay = calculateDelay(retryCount, e);
        logger.warn("Attempt {} of {} for {} failed. Retrying after {}ms. Error: {}", 
            retryCount, maxRetries, operationName, delay.toMillis(), e.getMessage());
        sleep(delay);
    }

    private Duration calculateDelay(int retryCount, Exception e) {
        Duration baseDelay;
        if (e instanceof NvdApiException nvdEx && nvdEx.getStatusCode() == 429) {
            baseDelay = Duration.ofSeconds(30); // Rate limit specific delay
        } else {
            baseDelay = initialDelay;
            for (int i = 1; i < retryCount; i++) {
                baseDelay = baseDelay.multipliedBy((long) backoffMultiplier);
            }
        }
        return baseDelay.compareTo(maxDelay) > 0 ? maxDelay : baseDelay;
    }

    private void sleep(Duration duration) {
        try {
            Thread.sleep(duration.toMillis());
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new NvdApiException("Interrupted while waiting for retry", e);
        }
    }
} 