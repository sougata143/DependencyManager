package org.infy.scanner.vulnerability;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import okhttp3.*;
import org.infy.scanner.core.Dependency;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.TimeUnit;

public class NvdVulnerabilityScanner implements VulnerabilityScanner {
    private static final Logger logger = LoggerFactory.getLogger(NvdVulnerabilityScanner.class);
    private static final String NVD_API_BASE_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0";
    
    private final OkHttpClient httpClient;
    private final ObjectMapper objectMapper;
    private final String apiKey;
    private final RetryHandler retryHandler;
    private final RateLimiter rateLimiter;

    public NvdVulnerabilityScanner(String apiKey) {
        if (apiKey == null || apiKey.trim().isEmpty()) {
            throw new IllegalArgumentException("NVD API key is required. Please set it in ~/.config/nvd/config.json");
        }
        
        this.apiKey = apiKey;
        this.httpClient = new OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .build();
        this.objectMapper = new ObjectMapper();
        this.retryHandler = new RetryHandler(3, Duration.ofSeconds(2), Duration.ofSeconds(30), 2.0);
        this.rateLimiter = new RateLimiter(30, Duration.ofSeconds(30));
    }

    @Override
    public Set<VulnerabilityResult> scanForVulnerabilities(Set<Dependency> dependencies) {
        Set<VulnerabilityResult> results = new HashSet<>();
        
        for (Dependency dependency : dependencies) {
            try {
                Set<VulnerabilityResult> dependencyResults = retryHandler.execute(
                    () -> scanDependency(dependency),
                    "vulnerability scan for " + dependency
                );
                results.addAll(dependencyResults);
            } catch (Exception e) {
                logger.error("Error scanning dependency: {}", dependency, e);
            }
        }
        
        return results;
    }

    private Set<VulnerabilityResult> scanDependency(Dependency dependency) {
        try {
            rateLimiter.acquire();
            try {
                return performScan(dependency);
            } catch (IOException e) {
                logger.error("IO error while scanning dependency: {}", dependency, e);
                throw new NvdApiException("Failed to scan dependency", e);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new NvdApiException("Interrupted while waiting for rate limit", e);
        }
    }

    private Set<VulnerabilityResult> performScan(Dependency dependency) throws IOException {
        Set<VulnerabilityResult> vulnerabilities = new HashSet<>();
        String cpeMatch = String.format("cpe:2.3:a:%s:%s:%s:*:*:*:*:*:*:*",
            dependency.groupId().replace(".", "-"),
            dependency.artifactId(),
            dependency.version());

        Request request = new Request.Builder()
            .url(NVD_API_BASE_URL + "?cpeName=" + cpeMatch)
            .addHeader("apiKey", apiKey)
            .build();

        try (Response response = httpClient.newCall(request).execute()) {
            if (!response.isSuccessful()) {
                handleErrorResponse(response);
            }

            JsonNode root = objectMapper.readTree(response.body().string());
            JsonNode vulnerabilityNodes = root.path("vulnerabilities");

            for (JsonNode vulnNode : vulnerabilityNodes) {
                VulnerabilityResult result = parseVulnerabilityNode(vulnNode, dependency);
                if (result != null) {
                    vulnerabilities.add(result);
                }
            }
        }

        return vulnerabilities;
    }

    private VulnerabilityResult parseVulnerabilityNode(JsonNode vulnNode, Dependency dependency) {
        try {
            JsonNode cveNode = vulnNode.path("cve");
            return new VulnerabilityResult(
                dependency,
                cveNode.path("id").asText(),
                parseSeverity(cveNode),
                cveNode.path("descriptions").path(0).path("value").asText(),
                LocalDateTime.parse(cveNode.path("published").asText()),
                parseRemediation(cveNode)
            );
        } catch (Exception e) {
            logger.warn("Error parsing vulnerability node: {}", e.getMessage());
            return null;
        }
    }

    private VulnerabilityResult.Severity parseSeverity(JsonNode cveNode) {
        String baseScore = cveNode.path("metrics").path("cvssMetricV31").path(0)
            .path("cvssData").path("baseScore").asText();
        
        double score = Double.parseDouble(baseScore);
        if (score >= 9.0) return VulnerabilityResult.Severity.CRITICAL;
        if (score >= 7.0) return VulnerabilityResult.Severity.HIGH;
        if (score >= 4.0) return VulnerabilityResult.Severity.MEDIUM;
        return VulnerabilityResult.Severity.LOW;
    }

    private String parseRemediation(JsonNode cveNode) {
        JsonNode configurations = cveNode.path("configurations");
        if (configurations.size() > 0) {
            return configurations.path(0).path("comment").asText();
        }
        return "No remediation information available";
    }

    private void handleErrorResponse(Response response) {
        int code = response.code();
        String message = String.format("NVD API request failed with status code: %d", code);
        
        boolean isRetryable = code == 429 || code >= 500;
        throw new NvdApiException(message, code, isRetryable);
    }
} 